<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Fluentx</name>
    </assembly>
    <members>
        <member name="T:Fluentx.Expresser`1">
            <summary>
            Experimental class: Expresser expresses an entity's properties in a strongly typed format using lambda expressions, instead of 
            creating too many POCO's you can use the expresser to transfer the entity's data that you want.
            </summary>
            <typeparam name="TEntity"></typeparam>    
        </member>
        <member name="M:Fluentx.Expresser`1.Set``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="expression"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.Set(System.String,System.Object)">
            <summary>
            
            </summary>
            <param name="memberPath"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.TrySet``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},``0)">
            <summary>
            
            </summary>
            <typeparam name="TValue"></typeparam>
            <param name="expression"></param>
            <param name="value"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.Set(`0,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            Expressers all direct public properties and fields within the entity EXCEPT what has has been specified.
            </summary>
            <param name="entity"></param>
            <param name="excepters"></param>
        </member>
        <member name="M:Fluentx.Expresser`1.Get``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            
            </summary>
            <typeparam name="TReturn"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Expresser`1.TryGet``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            
            </summary>
            <typeparam name="TReturn"></typeparam>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Expresser`1.RecursiveExpressionPath(System.String,System.Linq.Expressions.MemberExpression)">
            <summary>
            
            </summary>
            <param name="path"></param>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Expresser`1.Create(`0,System.Linq.Expressions.Expression{System.Func{`0,System.Object}}[])">
            <summary>
            
            </summary>
            <param name="entity"></param>
            <param name="excepters"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Extensions">
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
            <summary>
            Set of very useful extension methods for hour by hour use in .NET code.
            </summary>
        </member>
        <member name="M:Fluentx.Extensions.Not(System.Boolean)">
            <summary>
            Negates a condition
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.And(System.Boolean,System.Boolean)">
            <summary>
            Anding with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.And(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Anding with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.AndNot(System.Boolean,System.Boolean)">
            <summary>
            Anding Not with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.AndNot(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Anding Not with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Or(System.Boolean,System.Boolean)">
            <summary>
            Oring with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Or(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Oring with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.OrNot(System.Boolean,System.Boolean)">
            <summary>
            Oring Not with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.OrNot(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Oring Not with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Xor(System.Boolean,System.Boolean)">
            <summary>
            Xoring with a condition
            </summary>
            <param name="this"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Xor(System.Boolean,System.Func{System.Boolean})">
            <summary>
            Xoring with a condition predicate
            </summary>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.FormatWith(System.String,System.Object[])">
            <summary>
            Extension method that performs the operation string.Format 
            </summary>
            <param name="this"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.To``1(System.IConvertible)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt32(System.String,System.Int32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt32(System.String,System.UInt32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt(System.String,System.Int32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt(System.String,System.UInt32)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToLong(System.String,System.Int64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToULong(System.String,System.UInt64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt16(System.String,System.Int16)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt16(System.String,System.UInt16)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToInt64(System.String,System.Int64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToUInt64(System.String,System.UInt64)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToDouble(System.String,System.Double)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToFloat(System.String,System.Single)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToDecimal(System.String,System.Decimal)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToByte(System.String,System.Byte)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToSByte(System.String,System.SByte)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToBool(System.String,System.Boolean)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToDateTime(System.String,System.DateTime)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToGuid(System.String,System.Guid)">
            <summary>
            Extension method that tries to parse the string, if parsing faild it returns the default value (specified default value or implicit default value).
            </summary>
            <param name="this"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IgnoreCaseEqual(System.String,System.String)">
            <summary>
            Extension method to compare two strings for equality ignoring character case. (Note: uses Equals(string, StringComparison.OrdinalIgnoreCase)).
            </summary>
            <param name="this"></param>
            <param name="compareOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Wordify(System.String)">
            <summary>
            Returns a string that holds the words splitted by space.e.g. thisIsGood => this Is Good
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WordCount(System.String,Fluentx.Extensions.WordCountAlgorithm)">
            <summary>
            Counts the words within the specified strings, two algorithms can be used, Regex is the default one used: more accurate but slower. Loop method is much much faster but less accurate.
            </summary>
            <param name="this"></param>
            <param name="algorithm"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Reverse(System.String)">
            <summary>
            Reverses the specifed string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.January(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in January of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.February(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in February of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.March(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in March of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.April(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in April of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.May(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in May of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.June(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in June of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.July(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in July of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.August(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in August of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.September(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in September of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.October(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in October of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.November(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in November of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.December(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date in December of the specified year or current year.
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.DayInYear(System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns the date of the specifed day in year. e.g 365.DayInYear(2014) => 31/12/2014
            </summary>
            <param name="this"></param>
            <param name="year"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.SecondsAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of seconds
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinutesAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of minutes
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.HoursAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of hours
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.DaysAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of days
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MonthsAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of months
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.YearsAgo(System.Int32)">
            <summary>
            Returns the current datetime - the specifed number of years
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.SecondsFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of seconds
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinutesFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of minutes
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.HoursFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of hours
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.DaysFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of days
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MonthsFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of months
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.YearsFromNow(System.Int32)">
            <summary>
            Returns the current datetime + the specifed number of years
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsWithin(System.DateTime,Fluentx.Period)">
            <summary>
            Returns a boolean value wether the date is within the specifed period. (edges are not calculated within)
            </summary>
            <param name="this"></param>
            <param name="period"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.EndOfDay(System.DateTime)">
            <summary>
            Returns end of day 23:59:59;
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.StartOfDay(System.DateTime)">
            <summary>
            Returns start of day 00:00:00
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NextDay(System.DateTime)">
            <summary>
            Returns next day of the specified day
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Extension method to perform For Each operation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            (Synonym to ForEach) Extension method to perform For Each operation.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            (Synonym to ForEach) Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Random``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Extension method to perform random return of an item within the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNull``1(``0)">
            <summary>
            Extension method to evaluate if object is null.
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNotNull``1(``0)">
            <summary>
            Extension method to evaluate if object is not null
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.In``1(``0,``0[])">
            <summary>
            Extension method to evaluate if the specified object exists within the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NotIn``1(``0,``0[])">
            <summary>
            Extension method to evaluate if the specified object doest not exists within the specified list.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Extension method that returns whether the specified Enumerable is null or empty.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IfTrue(System.Boolean,System.Action)">
            <summary>
            Extension method that performs the action if the value is true.
            </summary>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.IfTrue``1(System.Boolean,System.Func{``0})">
            <summary>
            Returns the specified expression value when the value is true.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WhenTrue``1(System.Boolean,``0)">
            <summary>
            Returns the specified expression value when the value is true.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WhenFalse``1(System.Boolean,System.Func{``0})">
            <summary>
            Returns the specified expression value when the value is false.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="exp"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.WhenFalse``1(System.Boolean,``0)">
            <summary>
            Returns the specified expression value when the value is false.
            </summary>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.IfFalse(System.Boolean,System.Action)">
            <summary>
            Extension method that performs the action if the value is false. Returns the same boolean value.
            </summary>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Is``1(``0)">
            <summary>
            Extension method that performs a boolean evaluation if @this is of type T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.As``1(``0)">
            <summary>
            Extension method that performs a safe cast for @this as T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Lock``1(``0,System.Action{``0})">
            <summary>
            Performs a lock operation (using a private object) on the specified action with @this as the parameter for the action.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Between``1(``0,``0,``0)">
            <summary>
            Returns if a @this in between the specified range.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="lower"></param>
            <param name="upper"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ParseEnum``1(System.String,System.Boolean)">
            <summary>
            Parses a string to enum and throughs exceptions as if it fails.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ignorecase"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.TryParseEnum``1(System.String,System.Boolean)">
            <summary>
            Tries to Parse a string as an enum, if failed it returns the default value of the provided Type.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="value"></param>
            <param name="ignorecase"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Set``1(``0,System.Action{``0})">
            <summary>
            Simple update of instance memebers using lambda expression.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Extensions.Safe``2(``0,System.Func{``0,``1})">
            <summary>
            Safely tries to evaluate the specified expression path
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToCSV``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns a comma separated string of the specified enumerable
            </summary>
            <param name="list"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the min element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MinBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the min element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Returns the max element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.MaxBy``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns the max element in the IEnumerable according to the predicate
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TMember"></typeparam>
            <param name="source"></param>
            <param name="predicate"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.Shuffle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Shuffles the specified enumeration randomly
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.K(System.Int32)">
            <summary>
            K stands for Kilo. The value mutliplied by 1024. e.g. 3.K()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.M(System.Int32)">
            <summary>
            M stands for Meda. The value mutliplied by 1024 * 1024. e.g. 4.M()
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.EmptyIfNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns an empty Enumerable if the specified enumerable is null.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.NullOr``2(``0,System.Func{``0,``1},``1)">
            <summary>
            Tries to return the value of the specifed expression without checking for nullability.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="this"></param>
            <param name="exp"></param>
            <param name="elseValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Converts all elements of the specified enum to a concatenated string.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Extensions.ToString``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.String},System.String)">
            <summary>
            Converts all elements of the specified enum to a concatenated string using the specifed exp.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="exp"></param>
            <param name="separator"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Extensions.WordCountAlgorithm">
            <summary>
            Enumeration to specify which algorithm to use when counting words for the WordCount extension method
            </summary>
        </member>
        <member name="F:Fluentx.Extensions.WordCountAlgorithm.Regex">
            <summary>
            Uses regular expressions to count words, its not fast for long strings but its accurate in terms of comparing to Microsoft Word, deviation is 0.02%.
            Note: this benchmark is taken from http://www.dotnetperls.com
            </summary>
        </member>
        <member name="F:Fluentx.Extensions.WordCountAlgorithm.Loop">
            <summary>
            Uses a simple loop to check characters and count words, this method is faster than regex, but less accurate.
            </summary>
        </member>
        <member name="T:Fluentx.Fx">
            <summary>
            Fx is the main class for Fluentx and its a shortened name for Fluentx, Fx also is equivelant for the mathematical representation of F(x) :)
            </summary>
        </member>
        <member name="T:Fluentx.IFluentInterface">
            <summary>
            Represnt the core of a fluent interface in fluentx
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.GetType">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.GetType"/> method from IntelliSense.
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.GetHashCode">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.GetHashCode"/> method from IntelliSense.
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.ToString">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.ToString"/> method from IntelliSense.
            </summary>
        </member>
        <member name="M:Fluentx.IFluentInterface.Equals(System.Object)">
            <summary>
            Redeclaration that hides the <see cref="M:System.Object.Equals(System.Object)"/> method from IntelliSense.
            </summary>
        </member>
        <member name="T:Fluentx.IAction">
            <summary>
            Represnt an Action for fluentx
            </summary>
        </member>
        <member name="T:Fluentx.ITriableAction">
            <summary>
            Any action might or might not complete successfully.
            </summary>
        </member>
        <member name="M:Fluentx.ITriableAction.Swallow">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``1">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``2">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``3">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.SwallowIf``4">
            <summary>
            
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <typeparam name="Exception4"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.Catch(System.Action{System.Exception})">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.Catch``1(System.Action{``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ITriableAction.Catch``2(System.Action{``0},System.Action{``1})">
            <summary>
            
            </summary>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="action1"></param>
            <param name="action2"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.IConditionBuilder">
            <summary>
            Any condition builder.
            </summary>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Then(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.And(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.And(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.AndNot(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.AndNot(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Or(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Or(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.OrNot(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.OrNot(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xor(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xnor(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionBuilder.Xnor(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.IConditionalAction">
            <summary>
            Any condition action.
            </summary>
        </member>
        <member name="M:Fluentx.IConditionalAction.Else(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionalAction.ElseIf(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IConditionalAction.ElseIf(System.Boolean)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.IEarlyLoopBuilder">
            <summary>
            Any early loop builder (e.g while)
            </summary>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.Do(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.LateBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.LateContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.IEarlyLoopBuilder.EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ILoopAction">
            <summary>
            Any loop action.
            </summary>
        </member>
        <member name="T:Fluentx.ILateLoopBuilder">
            <summary>
            Any late loop builder (e.g Do-While)
            </summary>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.While(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.LateBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.LateContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ILateLoopBuilder.EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.IEarlyLoop">
            <summary>
            Any early loop (e.g while).
            </summary>
        </member>
        <member name="M:Fluentx.IEarlyLoop.Do(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ILateLoop">
            <summary>
            Any late loop (e.g Do-While).
            </summary>
        </member>
        <member name="M:Fluentx.ILateLoop.While(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchBuilder">
            <summary>
            Switch statement builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchBuilder.Case``1(``0)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="compareOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISwitchBuilder.Default(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchCaseBuilder">
            <summary>
            Switch case statement builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchCaseBuilder.Execute(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchTypeBuilder">
            <summary>
            Switch statement for Types builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchTypeBuilder.Case``1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISwitchTypeBuilder.Default(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISwitchTypeCaseBuilder">
            <summary>
            Switch case statement for types builder.
            </summary>
        </member>
        <member name="M:Fluentx.ISwitchTypeCaseBuilder.Execute(System.Action)">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileTrue(System.Func{System.Boolean})">
            <summary>
            Performs a while control as long the action is evaluating to true.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileFalse(System.Func{System.Boolean})">
            <summary>
            Performs a while control as long the action is evaluating to false.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileTrueFor(System.Func{System.Boolean},System.UInt16)">
            <summary>
            Performs a while control as long the action is evaluating to true for a maximum of <paramref name="maxLoops"/>
            </summary>
            <param name="action"></param>
            <param name="maxLoops"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.WhileFalseFor(System.Func{System.Boolean},System.UInt16)">
            <summary>
            Performs a while control as long the action is evaluating to false for a maximum of <paramref name="maxLoops"/>
            </summary>
            <param name="action"></param>
            <param name="maxLoops"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.While(System.Func{System.Boolean},System.Action)">
            <summary>
            Performs a while control using the evaluation condition for the specified action.
            </summary>
            <param name="condition"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.While(System.Boolean,System.Action)">
            <summary>
            Performs a while control using specified condition for the specified action.
            </summary>
            <param name="condition"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.While(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of a while statement using the specified condition, this requires the call to Do eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Do(System.Action)">
            <summary>
            Prepare for the excution of a Do-While statement using the specified condition, this requires the call to While eventually.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.If(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of IF statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.If(System.Boolean)">
            <summary>
            Prepare for the excution of IF statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.When(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of IF statement (alternative for IF), requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.When(System.Boolean)">
            <summary>
            Prepare for the excution of IF statement (alternative for IF), requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.IfNot(System.Func{System.Boolean})">
            <summary>
            Prepare for the excution of IF NOT statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.IfNot(System.Boolean)">
            <summary>
            Prepare for the excution of IF NOT statement, requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEach``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Prepares for the execution of a foreach statement, this requires the call to Do eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            (Synonym to ForEach) Performs a foreach loop on the specified list by excuting action for each item in the Enumerable providing the current index of the item.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEvery``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Performs a foreach loop on the specified list by excuting action for each item in the Enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ForEvery``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            (Synonym to ForEach) Prepares for the execution of a foreach statement, this requires the call to Do eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Try(System.Action)">
            <summary>
            Prepares for the excution of a Try/Catch action, this requires the call to one of the following actions eventually: Catch, Swallow, SwalloIf.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Using``1(``0,System.Action{``0})">
            <summary>
            Performs a using statement for disposable objects by executing action.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Switch``1(``0)">
            <summary>
            Prepares for a switch statement over the specified mainOperand, this requires the call to Default eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="mainOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Switch(System.Type)">
            <summary>
            Prepares for a switch statement over the specified type, this requires the call to Default eventually.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Switch``1">
            <summary>
            Prepares for a switch statement over the specified type T, this requires the call to Default eventually.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.RetryOnFail(System.Func{System.Boolean},System.UInt16,System.UInt16)">
            <summary>
            Performs an action, if the action failed (returned false) it re-attempts to do the action again for <paramref name="attempts"/>, and waits for <paramref name="attemptSleepInMilliSeconds"/> between each attempt.
            </summary>
            <param name="action"></param>
            <param name="attempts"></param>
            <param name="attemptSleepInMilliSeconds"></param>
        </member>
        <member name="M:Fluentx.Fx.ToInt32(System.String,System.Int32)">
            <summary>
            Tries to parse specified string to Int32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt32(System.String,System.UInt32)">
            <summary>
            Tries to parse specified string to UInt32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToInt(System.String,System.Int32)">
            <summary>
            Tries to parse specified string to Int32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt(System.String,System.UInt32)">
            <summary>
            Tries to parse specified string to UInt32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToLong(System.String,System.Int64)">
            <summary>
            Tries to parse specified string to Int32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToULong(System.String,System.UInt64)">
            <summary>
            Tries to parse specified string to UInt32, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToInt16(System.String,System.Int16)">
            <summary>
            Tries to parse specified string to Int16, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt16(System.String,System.UInt16)">
            <summary>
            Tries to parse specified string to UInt16, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToInt64(System.String,System.Int64)">
            <summary>
            Tries to parse specified string to Int64, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToUInt64(System.String,System.UInt64)">
            <summary>
            Tries to parse specified string to UInt64, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToDouble(System.String,System.Double)">
            <summary>
            Tries to parse specified string to double, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToFloat(System.String,System.Single)">
            <summary>
            Tries to parse specified string to float, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToDecimal(System.String,System.Decimal)">
            <summary>
            Tries to parse specified string to decimal, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToByte(System.String,System.Byte)">
            <summary>
            Tries to parse specified string to byte, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToSByte(System.String,System.SByte)">
            <summary>
            Tries to parse specified string to sbyte, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToBool(System.String,System.Boolean)">
            <summary>
            Tries to parse specified string to bool, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToDateTime(System.String,System.DateTime)">
            <summary>
            Tries to parse specified string to DateTime, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.ToGuid(System.String,System.Guid)">
            <summary>
            Tries to parse specified string to Guid, if it fails it returns the default value specified.
            </summary>
            <param name="strValue"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Is(System.Func{System.Boolean})">
            <summary>
            
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Lock(System.Action)">
            <summary>
            Performs a lock operation (using a private object) on the specified action.
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:Fluentx.Fx.Lock``1(System.Func{``0})">
            <summary>
            Performs a lock operation (using a private object) on the specified action and return the operation return value;
            </summary>
            <typeparam name="T"></typeparam>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Lock``1(``0,System.Action{``0})">
            <summary>
            Performs a lock operation (using a private object) on the specified action and return @this;
            </summary>
            <typeparam name="T"></typeparam>
            <param name="this"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionalAction#Else(System.Action)">
            <summary>
            Performs the else part of the if statement its chained to.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionalAction#ElseIf(System.Func{System.Boolean})">
            <summary>
            Prepares for the extra ElseIf condition, this requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionalAction#ElseIf(System.Boolean)">
            <summary>
            Prepares for the extra ElseIf condition, this requires the call to Then eventually.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Then(System.Action)">
            <summary>
            Performs the action for the previous conditional control statment (If, ElseIf).
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#And(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#And(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#AndNot(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#AndNot(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using AND NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Or(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Or(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#OrNot(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#OrNot(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using OR NOT.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xor(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using XOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xor(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using XOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xnor(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition with the previously chained condition using XNOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IConditionBuilder#Xnor(System.Boolean)">
            <summary>
            Evaluates the specified condition with the previously chained condition using XNOR.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#Do(System.Action)">
            <summary>
            Performs the specified action after evaluating the previous looping statement.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#While(System.Func{System.Boolean})">
            <summary>
            Performs the while statement using the specified condition statement after evaluating the previous Do statement.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#LateBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#LateContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoopBuilder#EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#IEarlyLoop#Do(System.Action)">
            <summary>
            Performs the Do statement after evaluating the previous looping statement.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#LateBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#EarlyBreakOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to break the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#LateContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment lately (before the end of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoopBuilder#EarlyContinueOn(System.Func{System.Boolean})">
            <summary>
            Evaluates the specified condition to be used to continue the looping statment early (at the begining of the loop).
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ILateLoop#While(System.Func{System.Boolean})">
            <summary>
            Performs the while statement using the specifed condition after it has evaluated the previous chained Do statement.
            </summary>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Swallow">
            <summary>
            Performs the previously chained Try action and swallow any exception that might occur.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``1">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``2">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``3">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#SwallowIf``4">
            <summary>
            Performs the previously chained Try action and swallow only the specified Exception(s).
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <typeparam name="Exception3"></typeparam>
            <typeparam name="Exception4"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Catch(System.Action{System.Exception})">
            <summary>
            Performs the previously chained Try action and catches any exception and performs the specified action for the catch.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Catch``1(System.Action{``0})">
            <summary>
            Performs the previously chained Try action and catches the specified exception(s) and performs the specified action for each catch.
            </summary>
            <typeparam name="Exception1"></typeparam>
            <param name="action1"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ITriableAction#Catch``2(System.Action{``0},System.Action{``1})">
            <summary>
            Performs the previously chained Try action and catches the specified exception(s) and performs the specified action for each catch.
            </summary>
            <typeparam name="Exception1"></typeparam>
            <typeparam name="Exception2"></typeparam>
            <param name="action1"></param>
            <param name="action2"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchBuilder#Case``1(``0)">
            <summary>
            Prepares a Case statement for the previously chained Switch statement, this requires the usage of Execute after it.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="compareOperand"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchTypeBuilder#Case``1">
            <summary>
            Prepares a Case statement for the previously chained Switch statement, this requires the usage of Execute after it.
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchCaseBuilder#Execute(System.Action)">
            <summary>
            Prepares for the execution of the specified action in case its chained Case has been evaluated.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchTypeCaseBuilder#Execute(System.Action)">
            <summary>
            Prepares for the execution of the specified action in case its chained Case has been evaluated.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchBuilder#Default(System.Action)">
            <summary>
            Performs the previously chained switch statement along with its chained cases.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.Fluentx#ISwitchTypeBuilder#Default(System.Action)">
            <summary>
            Performs the previously chained switch statement along with its chained cases.
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Fx.TernaryOperator(System.Boolean,System.Action,System.Action)">
            <summary>
            
            </summary>
            <param name="condition"></param>
            <param name="trueAction"></param>
            <param name="falseAction"></param>
        </member>
        <member name="P:Fluentx.Fx.Action">
            <summary>
            Used for a single default action
            </summary>
        </member>
        <member name="T:Fluentx.Fx.CaseInfo">
            <summary>
            Private class to hold information about switch case statement.
            </summary>
        </member>
        <member name="T:Fluentx.Guard">
            <summary>
            Behavioural presenation of throwing expected exceptions
            </summary>
        </member>
        <member name="M:Fluentx.Guard.Against(System.Boolean,System.String)">
            <summary>
            Will throw a <see cref="T:System.InvalidOperationException"/> if the assertion
            is true, with the specificied message.
            </summary>
            <param name="assertion">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            Guard.Against(string.IsNullOrEmpty(name), "Name must have a value");
            </code>
            </example>
        </member>
        <member name="M:Fluentx.Guard.Against(System.Func{System.Boolean},System.String)">
            <summary>
            Will throw a <see cref="T:System.InvalidOperationException"/> if the assertionAction
            is true, with the specificied message.
            </summary>
            <param name="asseertionAction"></param>
            <param name="message"></param>
        </member>
        <member name="M:Fluentx.Guard.Against``1(System.Boolean,System.String)">
            <summary>
            Will throw exception of type <typeparamref name="TException"/>
            with the specified message if the assertion is true
            </summary>
            <typeparam name="TException"></typeparam>
            <param name="assertion">if set to <c>true</c> [assertion].</param>
            <param name="message">The message.</param>
            <example>
            Sample usage:
            <code>
            <![CDATA[
            Guard.Against<ArgumentException>(string.IsNullOrEmpty(name), "Name must have a value");
            ]]>
            </code>
            </example>
        </member>
        <member name="M:Fluentx.Guard.Against``1(System.Func{System.Boolean},System.String)">
            <summary>
            Will throw exception of type <typeparamref name="TException"/>
            with the specified message if the assertion is true
            </summary>
            <typeparam name="TException"></typeparam>
            <param name="asseertionAction"></param>
            <param name="message"></param>
        </member>
        <member name="T:Fluentx.MultitionaryBase`2">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TKuple"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`2">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`3">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`4">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`5">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`6">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`7">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
        </member>
        <member name="T:Fluentx.Multitionary`8">
            <summary>
            Multi-value dictionary identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
        </member>
        <member name="T:Fluentx.IKuple">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
        </member>
        <member name="T:Fluentx.IKuple`1">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`8">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
            <typeparam name="T7"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`7">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
            <typeparam name="T6"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`6">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
            <typeparam name="T5"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`5">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
            <typeparam name="T4"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`4">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
            <typeparam name="T3"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`3">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
            <typeparam name="T2"></typeparam>
        </member>
        <member name="T:Fluentx.Kuple`2">
            <summary>
            Interface to represent multivalue data structures identified by a key
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="T1"></typeparam>
        </member>
        <member name="T:Fluentx.IMapper">
            <summary>
            Main Interface for fluentx object to object mapper
            </summary>
        </member>
        <member name="P:Fluentx.IMapper.SourceType">
            <summary>
            Mapper Source Type 
            </summary>
        </member>
        <member name="P:Fluentx.IMapper.DestinationType">
            <summary>
            Mapper Destination Type
            </summary>
        </member>
        <member name="T:Fluentx.IMapper`2">
            <summary>
            When overriden it provides functionalities to map from object to object (source to destination) using convention based mapping and a set of custom user rules mapping.
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TDestination"></typeparam>
        </member>
        <member name="M:Fluentx.IMapper`2.Conditional(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally maps the specified destination member from the source instance if found according to conditionalAction value.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.For``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0})">
            <summary>
            Maps the specified destination member using the specified resolver.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.ForIf``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0},System.Func{`0,System.Boolean})">
            <summary>
            Maps the specified destination member using the specified resolver if the conditionalAction evaluated to true
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <param name="conditionalAction">The action which its value will determine if to map using the resolver specified or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Ignore(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Ignores mapping of the specified destination member
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.IgnoreIf(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally ignores the specified destination member from mapping
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.UseMapper``2(Fluentx.IMapper{``0,``1})">
            <summary>
            Adds the specified mapper to the list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <typeparam name="TSrc">Type of source instance to map from</typeparam>
            <typeparam name="TDest">Type of destination instance to map to</typeparam>
            <param name="subMapper">An instance of a mapper that will be used as a sub mapper in the current mapper in case a match is found for mapping</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.UseMapper``2">
            <summary>
            Creates and adds a new mapper to list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <typeparam name="TSrc">Type of source instance to map from</typeparam>
            <typeparam name="TDest">Type of destination instance to map to</typeparam>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Resolve(System.Action{`0,`1})">
            <summary>
            Use this method to do custom actions through the mapper, handy to tigh custom resolvings with the mapper. Resolvers are the last things to be executed throught the mapper.
            </summary>
            <param name="resolver">Custom action to do whatever on the mapper</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Map(`0)">
            <summary>
            Executes mapping and returns the destination instance mapped using the mapping rules specified in the mapper instance.
            </summary>
            <param name="source">The source instance to map from</param>
            <returns>The destination instance which will be returned from the process of mapping</returns>
        </member>
        <member name="M:Fluentx.IMapper`2.Map(`0,`1)">
            <summary>
            Executes mapping between source and destination instances
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.Mapper`2">
            <summary>
            This class is used to do object to object mapping (source to destination) using convention based mapping and custom rules mapping
            </summary>
            <typeparam name="TSource"></typeparam>
            <typeparam name="TDestination"></typeparam>
        </member>
        <member name="M:Fluentx.Mapper`2.Create(System.Type,System.Type)">
            <summary>
            Creates a mapper using the specified source type and destination type
            </summary>
            <param name="sourceType"></param>
            <param name="destType"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Mapper`2.MapInstanceToInstance(`0,`1)">
            <summary>
            Executes mapping
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
        </member>
        <member name="M:Fluentx.Mapper`2.Conditional(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally maps the specified destination member from the source instance if found according to conditionalAction value.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.For``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0})">
            <summary>
            Maps the specified destination member using the specified resolver.
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.ForIf``1(System.Linq.Expressions.Expression{System.Func{`1,``0}},System.Func{`0,``0},System.Func{`0,System.Boolean})">
            <summary>
            Maps the specified destination member using the specified resolver if the conditionalAction evaluated to true
            </summary>
            <param name="destinationMember">The member on destination which will be mapped (its value updated)</param>
            <param name="resolver">The func action which will return the value and update the destination member</param>
            <param name="conditionalAction">The action which its value will determine if to map using the resolver specified or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Ignore(System.Linq.Expressions.Expression{System.Func{`1,System.Object}})">
            <summary>
            Ignores mapping of the specified destination member
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.IgnoreIf(System.Linq.Expressions.Expression{System.Func{`1,System.Object}},System.Func{`0,System.Boolean})">
            <summary>
            Conditionally ignores the specified destination member from mapping
            </summary>
            <param name="destinationMember">The member on destination which will be ignored from mapping</param>
            <param name="conditionalAction">The action which its value will determine if to ignore or not mapping this member</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.UseMapper``2(Fluentx.IMapper{``0,``1})">
            <summary>
            Adds the specified mapper to the list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <typeparam name="TSrc">Type of source instance to map from</typeparam>
            <typeparam name="TDest">Type of destination instance to map to</typeparam>
            <param name="subMapper">An instance of a mapper that will be used as a sub mapper in the current mapper in case a match is found for mapping</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.UseMapper``2">
            <summary>
            Creates and adds a new mapper to list of mappers that will be used in case a name match and types match found during mapping.
            </summary>
            <typeparam name="TSrc">Type of source instance to map from</typeparam>
            <typeparam name="TDest">Type of destination instance to map to</typeparam>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Resolve(System.Action{`0,`1})">
            <summary>
            Use this method to do custom actions through the mapper, handy to tigh custom resolvings with the mapper. Resolvers are the last things to be executed throught the mapper.
            </summary>
            <param name="resolver">Custom action to do whatever on the mapper</param>
            <returns>Returns instance of IMapper for chaining purposes</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Map(`0)">
            <summary>
            Executes mapping and returns the destination instance mapped using the mapping rules specified in the mapper instance.
            </summary>
            <param name="source">The source instance to map from</param>
            <returns>The destination instance which will be returned from the process of mapping</returns>
        </member>
        <member name="M:Fluentx.Mapper`2.Map(`0,`1)">
            <summary>
            Executes mapping between source and destination instances
            </summary>
            <param name="source"></param>
            <param name="dest"></param>
            <returns></returns>
        </member>
        <member name="P:Fluentx.Mapper`2.SourceType">
            <summary>
            Mapper source type
            </summary>
        </member>
        <member name="P:Fluentx.Mapper`2.DestinationType">
            <summary>
            Mapper destination type
            </summary>
        </member>
        <member name="T:Fluentx.PagedData`1">
            <summary>
            A simple container class for paged data.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Fluentx.PagedData`1.Data">
            <summary>
            The paged data returned
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.TotalCount">
            <summary>
            Total count of data without paging
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.PageIndex">
            <summary>
            Page Index
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.PageSize">
            <summary>
            Page Size
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.SortBy">
            <summary>
            Sorty by
            </summary>
        </member>
        <member name="P:Fluentx.PagedData`1.SortDirection">
            <summary>
            Sort direction
            </summary>
        </member>
        <member name="T:Fluentx.Period">
            <summary>
            A class represents a time period between to date item instances.
            </summary>
        </member>
        <member name="M:Fluentx.Period.#ctor(System.DateTime,System.DateTime)">
            <summary>
            Creates a period with the specified start and end dates
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Fluentx.Period.IsOverlap(Fluentx.Period,System.Boolean)">
            <summary>
            Returns if the specified period overlaps with the current one, a boolean value indicates wether edges should be calculated in the overlap or not, by default its false
            </summary>
            <param name="otherPeriod"></param>
            <param name="edgesOverlap"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.Period.IsWrap(System.DateTime)">
            <summary>
            Returns a boolean wether the specified date is within the current period.(edges are not calculated within)
            </summary>
            <param name="date"></param>
            <returns></returns>
        </member>
        <member name="P:Fluentx.Period.Start">
            <summary>
            Period start datetime
            </summary>
        </member>
        <member name="P:Fluentx.Period.End">
            <summary>
            Period end datetime
            </summary>
        </member>
        <member name="P:Fluentx.Period.Length">
            <summary>
            Period length as a timespan
            </summary>
        </member>
        <member name="T:Fluentx.PredicateBuilder">
            <summary>
            Helps building prediates to provide And/Or true/false for linq expressions
            </summary>
        </member>
        <member name="M:Fluentx.PredicateBuilder.True``1">
            <summary>
            Presents a true predicate
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.False``1">
            <summary>
            Presents false predicates
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Ors a predicate with another
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            And a predicate with another
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.PredicateBuilder.Xor``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            XOring a predicate with another
            </summary>
            <typeparam name="T"></typeparam>
            <param name="expLeft"></param>
            <param name="expRight"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ISpecification`1">
            <summary>
            Represents the core of the specificaiton pattern
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.ISpecification`1.Validate(`0)">
            <summary>
            When overriden in a derived class does the validation on the specification (Rule(s)) and return if it succeeds
            </summary>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.ValidateWithMessages(`0)">
            <summary>
            When overriden in a derived class does the validaiton on the specification (Rule(s)) and return list of validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.And(Fluentx.ISpecification{`0})">
            <summary>
            And a specification with another
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.Or(Fluentx.ISpecification{`0})">
            <summary>
            Or a specificaiton with another
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ISpecification`1.Xor(Fluentx.ISpecification{`0})">
            <summary>
            Xor a specification with another
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.CompositeSpecification`1">
            <summary>
            Base abstract class for custom specifications 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.Validate(`0)">
            <summary>
            Executes and Validates the specificaiton
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specificaiton and return validation messages.
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.And(Fluentx.ISpecification{`0})">
            <summary>
            Current specification AND specified specification 
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.Or(Fluentx.ISpecification{`0})">
            <summary>
            Current specification OR specified specification 
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.CompositeSpecification`1.Xor(Fluentx.ISpecification{`0})">
            <summary>
            Current specification XOR specified specification 
            </summary>
            <param name="specification"></param>
            <returns></returns>
        </member>
        <member name="P:Fluentx.CompositeSpecification`1.Message">
            <summary>
            Message returned for the specificaiton validation
            </summary>
        </member>
        <member name="T:Fluentx.AndSpecification`1">
            <summary>
            Represents the And Specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.AndSpecification`1.#ctor(Fluentx.ISpecification{`0},Fluentx.ISpecification{`0})">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.AndSpecification`1.Validate(`0)">
            <summary>
            Executes and validates the specificaiton
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.AndSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specification and return validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.OrSpecification`1">
            <summary>
            Represents Or specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.OrSpecification`1.#ctor(Fluentx.ISpecification{`0},Fluentx.ISpecification{`0})">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.OrSpecification`1.Validate(`0)">
            <summary>
            Executes and valiates the specification
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.OrSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specification and return validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.XorSpecification`1">
            <summary>
            Represnts XOR specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.XorSpecification`1.#ctor(Fluentx.ISpecification{`0},Fluentx.ISpecification{`0})">
            <summary>
            
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:Fluentx.XorSpecification`1.Validate(`0)">
            <summary>
            Executes and validates the specification
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.XorSpecification`1.ValidateWithMessages(`0)">
            <summary>
            Executes and validates the specification and return validation meessages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.ExpressionSpecification`1">
            <summary>
            Represents an expression based specification
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.#ctor(System.Func{`0,System.Boolean})">
            <summary>
            
            </summary>
            <param name="expression"></param>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.#ctor(System.Func{`0,System.Boolean},System.String)">
            <summary>
            
            </summary>
            <param name="expression"></param>
            <param name="message"></param>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.Validate(`0)">
            <summary>
            Validate the specification and return true or false
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="M:Fluentx.ExpressionSpecification`1.ValidateWithMessages(`0)">
            <summary>
            validates the specificaiton and return validation messages
            </summary>
            <param name="instance"></param>
            <returns></returns>
        </member>
        <member name="T:Fluentx.UISearch`1">
            <summary>
            A simple container class to transfer ui search related data.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Fluentx.UISearch`1.PageIndex">
            <summary>
            Page Index
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.PageSize">
            <summary>
            Page Size
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.SortBy">
            <summary>
            Sort By
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.SortDirection">
            <summary>
            Sort Direction
            </summary>
        </member>
        <member name="P:Fluentx.UISearch`1.Criteria">
            <summary>
            The criteria used for filter
            </summary>
        </member>
    </members>
</doc>
